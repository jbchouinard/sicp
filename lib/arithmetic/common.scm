; Arithmetic Common
(require "sicp.generic")

(define scheme-add +)
(define scheme-mul *)
(define scheme-sub -)
(define scheme-div /)

(define (neg x) (apply-generic 'neg (list x)))
(define (recip x) (apply-generic 'recip (list x)))
(define (add x y) (apply-generic 'add (list x y)))
(define (sub x y) (apply-generic 'sub (list x y)))
(define (mul x y) (apply-generic 'mul (list x y)))
(define (div x y) (apply-generic 'div (list x y)))

(define (+ . ns) (fold-left add 0 ns))
(define (* . ns) (fold-left mul 1 ns))
(define (- n . ns)
  (if (null? ns)
    (neg n)
    (fold-left sub n ns)))
(define (/ n . ns)
  (if (null? ns)
    (recip n)
    (fold-left div n ns)))

(define (make-scheme-number n)
  (make-generic 'scheme-number (list n)))

(define (install-scheme-number)
  ; Implementation
  (define (tag item) item)
  ; Interface
  (put 'make 'scheme-number (lambda (x) (x)))
  (put 'neg '(scheme-number)
    (lambda (x) (tag (scheme-sub x))))
  (put 'recip '(scheme-number)
    (lambda (x) (tag (scheme-div x))))
  (put 'add '(scheme-number scheme-number)
    (lambda (x y) (tag (scheme-add x y))))
  (put 'sub '(scheme-number scheme-number)
    (lambda (x y) (tag (scheme-sub x y))))
  (put 'sub '(scheme-number)
    (lambda (x) (tag (scheme-sub x))))
  (put 'mul '(scheme-number scheme-number)
    (lambda (x y) (tag (scheme-mul x y))))
  (put 'div '(scheme-number scheme-number)
    (lambda (x y) (tag (scheme-div x y))))
  'done)
