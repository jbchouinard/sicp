; Arithmetic Package
(load-module "sicp.table")

(define opstable (make-table))
(define put (table-make-put opstable))
(define get (table-make-get opstable))

(define (get-tag item)
  (if (number? item)
    'scheme-number
    (car item)))

(define (get-content item)
  (if (number? item)
    item
    (cdr item)))

(define (attach-tag tag content)
  (cons tag content))

(define (apply-generic op args)
  (let ((types (map get-tag args))
        (vals (map get-content args)))
    (let ((func (get op types)))
      (if (eq? false func)
        (error "not implemented -- APPLY-GENERIC" op types)
        (apply func vals)))))

(define (make-generic type args)
  (let ((func (get 'make type)))
    (if (eq? false func)
      (error "not implemented -- MAKE-GENERIC" type)
      (apply func args))))

(define scheme-add +)
(define scheme-mul *)
(define scheme-sub -)
(define scheme-div /)

(define (neg x) (apply-generic 'neg (list x)))
(define (recip x) (apply-generic 'recip (list x)))
(define (add x y) (apply-generic 'add (list x y)))
(define (sub x y) (apply-generic 'sub (list x y)))
(define (mul x y) (apply-generic 'mul (list x y)))
(define (div x y) (apply-generic 'div (list x y)))

(define (+ . ns) (fold-left add 0 ns))
(define (* . ns) (fold-left mul 1 ns))
(define (- n . ns)
  (if (null? ns)
    (neg n)
    (fold-left sub n ns)))
(define (/ n . ns)
  (if (null? ns)
    (recip n)
    (fold-left div n ns)))

(define (make-scheme-number n)
  (make-generic 'scheme-number (list n)))
(define (make-rational n d)
  (make-generic 'rational (list n d)))

(define (install-scheme-number)
  ; Implementation
  (define (tag item) item)
  ; Interface
  (put 'make 'scheme-number (lambda (x) (x)))
  (put 'neg '(scheme-number)
    (lambda (x) (tag (scheme-sub x))))
  (put 'recip '(scheme-number)
    (lambda (x) (tag (scheme-div x))))
  (put 'add '(scheme-number scheme-number)
    (lambda (x y) (tag (scheme-add x y))))
  (put 'sub '(scheme-number scheme-number)
    (lambda (x y) (tag (scheme-sub x y))))
  (put 'sub '(scheme-number)
    (lambda (x) (tag (scheme-sub x))))
  (put 'mul '(scheme-number scheme-number)
    (lambda (x y) (tag (scheme-mul x y))))
  (put 'div '(scheme-number scheme-number)
    (lambda (x y) (tag (scheme-div x y))))
  'done)

(define (install-rational)
  ; Implementation
  (define (tag item) (attach-tag 'rational item))
  (define (make-rat num dnm)
    (if (= dnm 0)
      (error "division by zero -- MAKE-RAT" num dnm)
      (let ((d (gcd num dnm)))
        (cons (/ num d) (/ dnm d)))))
  (define num car)  ; get numerator
  (define dnm cdr)  ; get denominator
  (define (neg-rat r) (make-rat (- (num r)) (dnm r)))
  (define (recip-rat r) (make-rat (dnm r) (num r)))
  (define (add-rat r1 r2)
    (if (= (dnm r1) (dnm r2))
        (make-rat (+ (num r1) (num r2)) (dnm r1))
        (make-rat (+ (* (num r1) (dnm r2))
                     (* (num r2) (dnm r1)))
                  (* (dnm r1) (dnm r2)))))
  (define (sub-rat r1 r2)
    (add-rat r1 (neg-rat r2)))
  (define (mul-rat r1 r2)
    (make-rat (* (num r1) (num r2))
              (* (dnm r1) (dnm r2))))
  (define (div-rat r1 r2)
    (mul-rat r1 (recip-rat r2)))
  ; Interface
  (put 'make 'rational
    (lambda (n d) (tag (make-rat n d))))
  (put 'neg '(rational)
    (lambda (r) (tag (neg-rat r)))
  (put 'recip '(rational)
    (lambda (r) (tag (recip r)))
  (put 'add '(rational rational)
    (lambda (r1 r2) (tag (add-rat r1 r2))))
  (put 'sub '(rational rational)
    (lambda (r1 r2) (tag (sub-rat r1 r2))))
  (put 'mul '(rational rational)
    (lambda (r1 r2) (tag (mul-rat r1 r2))))
  (put 'div '(rational rational)
    (lambda (r1 r2) (tag (div-rat r1 r2))))
  'done)
